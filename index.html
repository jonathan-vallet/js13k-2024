<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>13 steps to death</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        width: 100%;
      }

      #game {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      #gameBackgroundCanvas {
        position: absolute;
        top: -5%;
        left: -5%;
        width: 110%;
        height: 110%;
        z-index: -1; /* Behind the main canvas */
        object-fit: cover;
        filter: blur(15px) brightness(50%); /* Apply blur and darken the background */
      }
    </style>
  </head>
  <body style="overflow: hidden">
    <div id="game">
      <canvas id="gameBackgroundCanvas"></canvas><canvas id="uiCanvas"></canvas
      ><canvas id="gameCanvas"></canvas>
    </div>
    <script>
      'use strict';
      const IMAGE_LIST = {
          arrow: '16LKZLA\\K^LZLBZLBZLLLLLLLLLLLLG',
          block:
            '16AXNAMYezeYNZnZNedeNqeYlYeqNqeYgNgYeqNqeYfMeYMfYeqNqeYfMeYMfYeqNqeYeMfZMeYeqNqeYeMeNYMeYeqNqeYeNfNeYeqNqeYlYeqNedeNZnZNYezeYMAXNA',
          characters:
            '144FPKQLPLLLLLLLLJNhNGNiNHNhNJPKQLPLPKQLPIMlMEMmMFMlMGNhNGNiNHNhNHNhNGNiNHNhNGMlMEMmMFMlMFMlMEMmMFMlMFMlMEMmMFMlMFMlMEMmMFMlMFMlMEMmMFMlMFMlMEMmMFMlMFMesereMEMeugMFMlMFMlMEMmMFMlMFMlMEMmMFMlMEMqeveqMEMufNEMqlqMEMereseMEMeugMFMlMFMereseMEMeugMFMlMFMrMrMrMFMqMseMqMFMlMEMqeveqMEMufNEMqlqMDMqeveqMEMufNEMqlqMFMqMrMqMGMqMuMHMjMGMrMrMrMFMqMseMqMFMlMFMrMrMrMFMqMseMqMFMlMFOtOGMtNHOtOFNqMrMqNFMqMuMHNhNGNqMrMqNFMqMuMHNhNFM[P[MGPYMGM[P[MDMZMtMZMFMtNHMZPZMEMZMtMZMFMtOGMZPZMDMZMZrZMZMFN[MFMZM^MZMCOYPYMYqMEQYNFMqM^OCMqYMYPYOFQ[MEO^MqMCMZM^MZMFMYMZMFMZM^MZMCMrM]NqMDMr\\MqMFN]MrMCMqN]MrMEMqNZMYqMEMrM]NEMqTqMGMYMqNGMqTqMEUANEO\\MHUDNAUGN\\MqMFUGN^NHOqMIN^NHMqNZMISHMZNqMIMZNqMJSIMqNZMHMrNrMIMrNJMrNrMJOrMHMrNrMHMrOJMrOJMrNrMJOrMJPKQLPLLLLLLLLJNhNGNiNHNhNJPKQLPLPKQLPIMlMEMmMFNjNGNhNGNiNHNhNHNhNGNiNHNhNGMlMEMmMFMlMFMlMEMmMFNjNFMlMEMmMFNjNFMgqhMEMmMFMlMFMlMEMmMFMlMFMlMEMmMFMlMFMeveMEMerjMFMlMFMgqhMEMmMFMlMFMgqhMEMmMFMlMEMqeveqMEMshMeMDMqlqMEMeveMEMerjMFMlMFMeveMEMerjMFMlMFMeqMrMqeMFMqMqgMqMeMDMgNgMEMqeveqMEMshMeMDMqlqMDMqeveqMEMshMeMDMqlqMFMqMrMqMGMqMqfrMfMEMeMfMeMGMeqMrMqeMFMqMqgMqMeMDMgNgMFMeqMrMqeMFMqMqgMqMeMDMgNgMGNtNHMtNfMFNhNHMqMrMqMGMqMqfrMfMEMeMfMeMHMqMrMqMGMqMqfrMfMEMeMfMeMGMZPZMHSeMEMYMhMYMFMYMtMYMGMtNfMEMYMhMYMFMYMtMYMGMtNfMEMYMhMYMFM[r[MGMYNYMANFMZMfMZMFMYQYNHSfMDMYMgPFNYQYMGTfMDMYNgOEMqN\\NqMFMZMqMHMqNYNYNqMEO\\MrMFMZqNqODMrNeQEMrM\\OGM[MrOEQeNrMCMrN\\NrMFMYMqMGMrN\\NrMCMrM\\PFMsPFPYNYMrMDP\\MrMEMqMZNqMFMrMYNYPDOrNrOGMrNHOrNrOEOqNrMIOYqMIMrNqOGMrNqOGMrNYNGOqNrMIMqNqMKMqMLMqNqMKOqMJMqNqMJMqOKMqOJMqOqMKOqME',
          crate:
            '16AXNANYnYOZVZNeNeqjNeNeMfqetfMeNeMfteqfMeNeNjqeNeNZVZOYnYOYXYO[MZM]OYNYMYNYPYNYMZMYNYMZMYNYPYNYMYNYO]MZM[NAXNA',
          flag: '48DYLCYLCYLBZLBZLBZLCMgLMlGMlGMkHMkHMkHMkHMkHMkHMkHMkHMkHMkHMlGMkHMFfGMLCMChHMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLCMLBZLBZLBZK',
          'gong-trigger':
            '16XQsevesNqfTfqNfOhNgNfNeteNfNfMeqPqeMfMAMeMeqMrMqeMeMBMeMeqPqeMeMBMeNeteNeMBMeMAMhMAMeMBMeMBPBMeMBMeMHMeMBMeMHMeMBMeMAQBMeMBMeMBQAMeMBOHOA',
          gong: '16F\\JZtZGYfvYEZe^rYC\\jYrYB[lYqYBZnZBYhthYBYgq\\qgYBYgqYrYqgYBYgq\\qgYBZgtgZBeZlZeCeZjZeEe`eGlD',
          'hole-filled':
            '16LLLAMANAMFXNANYnYOZVZNeNeqjNeNeMfqetfMeNeMfteqfMeNeNjqeNeNZVZOYnYOYXYMAM[MZM]MCMAYMYNYNAMLF',
          hole: '16LLLYA\\AYGbEYA`AYDdCYAbAYB\\MYNYM\\A\\MYMZMYM\\AZMYMYNYMYMZCZTZCZMYRYMZCZTZEYTYHRLI',
          'key-holder':
            '16LFdCYpYAZ{e\\qbe\\qYeYhYeYe\\qZfZfZe\\qYgZgYe\\qYgYhYe\\qZfZfZe\\qYeYhYeYe\\qbe\\oq[edqZpfYAdZA',
          key: '16FtKqPqIqMhMqHqMYNeMqHqMYNeMqHqM\\MqIqNYMqJqMeYMqJqNYMqJqMZMqKqNqLArLLLLLK',
          lock: '16FPKMtMIMq\\qMGMZhYqMEMZeqNYeYqMCNYeqPYeYqMAOYeqPYeYrPYfqNYfYrO[eqNYeYfqMYM\\ereYgMYAYM\\fYgMYCYM[MYgMYEYMYMfYeMYGYMhMYIYPYK\\F',
          rock: '16FPIOhNFMeresfMDMerYeueMCMfqZesfqMBMgqZgYfMBMiYgZNBNYkZqNBNYiZsMBMqgriqMAMqeqYgqMYgMAMYfqMYeqMYgMAMZeqMYfNYfMAOZNYPYMqBPEOLF',
          sand: '16ZMYV]MYV]MYW\\MYMYU^MYU^MZU^MZV]MYV]XM\\XM\\X[XN[XM\\X]XZ',
          trap: '16DNANANGVEQrQCNYM[N[NBMqMrYrMrMqMANZM\\q\\OqMrMYsMrMqO]N]OsNsMqYsN\\qYM]qYOqMqOsYrNAqZN[M[MqBNYqMsMrOCO[rZNFQrMJPF',
        },
        TILE_SIZE = 16;
      let zoomFactor = 1;
      const LEVEL_WIDTH = 20,
        LEVEL_HEIGHT = 10,
        uiCanvas = document.getElementById('uiCanvas'),
        uiCtx = uiCanvas.getContext('2d'),
        canvas = document.getElementById('gameCanvas'),
        ctx = canvas.getContext('2d'),
        backgroundCanvas = document.getElementById('gameBackgroundCanvas'),
        backgroundCtx = backgroundCanvas.getContext('2d');
      let backgroundTile,
        backgroundColors,
        collectedKeysNumber = 0;
      const ORIENTATION_UP = 0,
        ORIENTATION_RIGHT = 1,
        ORIENTATION_DOWN = 2,
        ORIENTATION_LEFT = 3,
        DEFAULT_ANIMATION_INTERVAL = 200,
        DEFAULT_REMOVAL_DURATION = 225,
        COLOR_SETS = {
          blueGreenSet: ['#024d53', '#599dbc', '#72d1c7', '#a9ffe6'],
          crateSet: ['#000', '#893a25', '#f89e61', '#863422'],
          greenSet: ['#000', '#527f67', '#a2ce69', '#d6f8e1'],
          sandSet: ['#cab168', '#e5d09e'],
          bronzeSet: ['#000', '#811c07', '#ca6137', '#ffb59c'],
        },
        DEFAULT_TILE_COLORS = {
          arrow: COLOR_SETS.blueGreenSet,
          block: COLOR_SETS.blueGreenSet,
          character: ['#000', '#e42c37', '#c07548', '#fdcbb0'],
          crate: COLOR_SETS.crateSet,
          lock: COLOR_SETS.greenSet,
          key: COLOR_SETS.greenSet,
          flag: COLOR_SETS.bronzeSet,
          'key-holder': COLOR_SETS.blueGreenSet,
          rock: COLOR_SETS.blueGreenSet,
          sand: COLOR_SETS.sandSet,
          gong: COLOR_SETS.bronzeSet,
          'gong-trigger': COLOR_SETS.bronzeSet,
        };
      let levelData = [
          { tile: 'arrow', x: 4, y: 7 },
          { tile: 'arrow', x: 4, y: 6, orientation: ORIENTATION_LEFT },
          { tile: 'arrow', x: 2, y: 4, orientation: ORIENTATION_LEFT },
          { tile: 'crate', x: 3, y: 6 },
          { tile: 'crate', x: 4, y: 6 },
          { tile: 'rock', x: 11, y: 2 },
          { tile: 'rock', x: 1, y: 3 },
          { tile: 'rock', x: 2, y: 3 },
          { tile: 'rock', x: 3, y: 3 },
          { tile: 'rock', x: 4, y: 3 },
          { tile: 'rock', x: 5, y: 3 },
          { tile: 'rock', x: 6, y: 3 },
          { tile: 'rock', x: 7, y: 3 },
          { tile: 'rock', x: 12, y: 3 },
          { tile: 'rock', x: 13, y: 3 },
          { tile: 'rock', x: 14, y: 3 },
          { tile: 'rock', x: 15, y: 3 },
          { tile: 'rock', x: 16, y: 3 },
          { tile: 'rock', x: 17, y: 3 },
          { tile: 'rock', x: 18, y: 3 },
          { tile: 'rock', x: 4, y: 4 },
          { tile: 'rock', x: 5, y: 4 },
          { tile: 'rock', x: 14, y: 4 },
          { tile: 'rock', x: 16, y: 4 },
          { tile: 'rock', x: 1, y: 5 },
          { tile: 'rock', x: 2, y: 5 },
          { tile: 'rock', x: 5, y: 5 },
          { tile: 'rock', x: 14, y: 5 },
          { tile: 'rock', x: 16, y: 5 },
          { tile: 'block', x: 8, y: 3, orientation: ORIENTATION_LEFT },
          { tile: 'block', x: 9, y: 3, orientation: ORIENTATION_LEFT },
          { tile: 'flag', x: 9, y: 2 },
          {
            tile: 'block',
            x: 10,
            y: 3,
            color: COLOR_SETS.greenSet,
            orientation: ORIENTATION_LEFT,
          },
          { tile: 'lock', x: 11, y: 3 },
          { tile: 'key-holder', x: 15, y: 4 },
          { tile: 'key', x: 15, y: 4 },
          { tile: 'gong-trigger', x: 1, y: 4 },
          { tile: 'gong', x: 15, y: 5 },
        ],
        zzfx = (...e) => zzfxP(zzfxG(...e)),
        zzfxP = (...e) => {
          let M = zzfxX.createBufferSource(),
            t = zzfxX.createBuffer(e.length, e[0].length, zzfxR);
          return (
            e.map((e, M) => t.getChannelData(M).set(e)),
            (M.buffer = t),
            M.connect(zzfxX.destination),
            M.start(),
            M
          );
        },
        zzfxG = (
          e = 1,
          M = 0.05,
          t = 220,
          r = 0,
          a = 0,
          n = 0.1,
          l = 0,
          i = 1,
          o = 0,
          N = 0,
          c = 0,
          s = 0,
          E = 0,
          q = 0,
          Y = 0,
          L = 0,
          f = 0,
          T = 1,
          g = 0,
          d = 0,
        ) => {
          let O,
            u,
            h = 2 * Math.PI,
            F = (o *= (500 * h) / zzfxR ** 2),
            I = ((0 < Y ? 1 : -1) * h) / 4,
            m = (t *= ((1 + 2 * M * Math.random() - M) * h) / zzfxR),
            C = [],
            A = 0,
            Z = 0,
            x = 0,
            k = 1,
            R = 0,
            S = 0,
            v = 0;
          for (
            N *= (500 * h) / zzfxR ** 3,
              Y *= h / zzfxR,
              c *= h / zzfxR,
              s *= zzfxR,
              E = (zzfxR * E) | 0,
              u =
                ((r = 99 + zzfxR * r) +
                  (g *= zzfxR) +
                  (a *= zzfxR) +
                  (n *= zzfxR) +
                  (f *= zzfxR)) |
                0;
            x < u;
            C[x++] = v
          )
            ++S % ((100 * L) | 0) ||
              ((v = l
                ? 1 < l
                  ? 2 < l
                    ? 3 < l
                      ? Math.sin((A % h) ** 3)
                      : Math.max(Math.min(Math.tan(A), 1), -1)
                    : 1 - (((((2 * A) / h) % 2) + 2) % 2)
                  : 1 - 4 * Math.abs(Math.round(A / h) - A / h)
                : Math.sin(A)),
              (v =
                (E ? 1 - d + d * Math.sin((2 * Math.PI * x) / E) : 1) *
                (0 < v ? 1 : -1) *
                Math.abs(v) ** i *
                e *
                zzfxV *
                (x < r
                  ? x / r
                  : x < r + g
                  ? 1 - ((x - r) / g) * (1 - T)
                  : x < r + g + a
                  ? T
                  : x < u - f
                  ? ((u - x - f) / n) * T
                  : 0)),
              (v = f
                ? v / 2 +
                  (f > x
                    ? 0
                    : ((x < u - f ? 1 : (u - x) / f) * C[(x - f) | 0]) / 2)
                : v)),
              (O = (t += o += N) * Math.sin(Z * Y - I)),
              (A += O - O * q * (1 - ((1e9 * (Math.sin(x) + 1)) % 2))),
              (Z += O - O * q * (1 - ((1e9 * (Math.sin(x) ** 2 + 1)) % 2))),
              k && ++k > s && ((t += c), (m += c), (k = 0)),
              !E || ++R % E || ((t = m), (o = F), (k = k || 1));
          return C;
        },
        zzfxV = 0.3,
        zzfxR = 44100,
        zzfxX = new (window.AudioContext || webkitAudioContext)(),
        pixelList = [];
      function decodeRLE(e) {
        const M = 'A'.charCodeAt(0),
          t = [],
          r = parseInt(e.match(/^\d+/)[0], 10);
        e = e.replace(/^\d+/, '');
        for (let r = 0; r < e.length; ++r) {
          const a = e[r].charCodeAt(0) - M,
            n = Math.floor(a / 12),
            l = (a % 12) + 1;
          t.push(...Array(l).fill(n));
        }
        return { pixels: t, imageWidth: r };
      }
      function convertTo2DArray(e, M) {
        const t = [];
        for (let r = 0; r < e.length; r += M) t.push(e.slice(r, r + M));
        return t;
      }
      function sliceIntoTiles(e, M, t) {
        const r = [],
          a = e.length,
          n = e[0].length;
        for (let l = 0; l < a; l += t)
          for (let a = 0; a < n; a += M) {
            const n = [];
            for (let r = 0; r < t; r++) n.push(e[l + r].slice(a, a + M));
            r.push(n);
          }
        return r;
      }
      function processSprite(e) {
        const M = decodeRLE(IMAGE_LIST[e]);
        pixelList = M.pixels;
        return {
          tiles: sliceIntoTiles(
            convertTo2DArray(M.pixels, M.imageWidth),
            16,
            16,
          ),
        };
      }
      function processAllSprites() {
        const e = [];
        for (const M in IMAGE_LIST) e[M] = processSprite(M);
        return e;
      }
      const GAME_SPRITES = processAllSprites(),
        initialLevelData = JSON.parse(JSON.stringify(levelData));
      function resetLevel() {
        (levelData = JSON.parse(JSON.stringify(initialLevelData))),
          (playerX = initialX),
          (playerY = initialY),
          (stepsRemaining = 13);
      }
      function getTileAt(e, M) {
        let t = null;
        for (const r of levelData) r.x === e && r.y === M && (t = r.tile);
        return t;
      }
      function removeTile(e, M = null, t = null) {
        levelData = levelData.filter(
          (r) =>
            r.tile !== e ||
            (null !== M && null !== t && (r.x !== M || r.y !== t)),
        );
      }
      function moveCrate(e, M, t, r) {
        const a = e + t,
          n = M + r,
          l = getTileAt(a, n);
        if (null === l || ['arrow'].includes(l))
          for (const t of levelData)
            if (t.x === e && t.y === M && 'crate' === t.tile)
              return (
                (t.x = a),
                (t.y = n),
                zzfx(...[, 0.1, 150, 0.05, , , , 1.3, , , , , , 3]),
                !0
              );
        return !1;
      }
      function removeConnectedBlocks(e, M, t, r) {
        animateTileRemoval('block', e, M);
        const a = e + t,
          n = M + r;
        if ('block' === getTileAt(a, n)) {
          const e = levelData.find(
            (e) => e.x === a && e.y === n && 'block' === e.tile,
          );
          if (e) {
            const M = e.orientation || ORIENTATION_UP;
            let t = 0,
              r = 0;
            M === ORIENTATION_LEFT
              ? (t = -1)
              : M === ORIENTATION_RIGHT
              ? (t = 1)
              : M === ORIENTATION_UP
              ? (r = -1)
              : M === ORIENTATION_DOWN && (r = 1),
              setTimeout(() => {
                removeConnectedBlocks(a, n, t, r);
              }, 120);
          }
        }
      }
      function animateTileRemoval(
        e,
        M = null,
        t = null,
        r,
        a = DEFAULT_REMOVAL_DURATION,
      ) {
        levelData
          .filter(
            (r) => r.tile === e && (null === M || (r.x === M && r.y === t)),
          )
          .forEach((e) => {
            (e.isBeingRemoved = !0),
              (e.scale = 1),
              (e.elapsed = 0),
              (e.removalDuration = a),
              (e.removeCallback = r);
          });
      }
      function refreshUI() {
        drawUI();
      }
      function drawUI() {
        (uiCtx.fillStyle = '#333'),
          uiCtx.fillRect(0, 0, uiCanvas.width, uiCanvas.height),
          adjustFontSize(`Steps: ${stepsRemaining}`),
          (uiCtx.fillStyle = 'white');
        const e = uiCanvas.height / 2 + uiCtx.font.match(/\d+/)[0] / 2;
        uiCtx.fillText(`Steps: ${stepsRemaining}`, 0.02 * uiCanvas.width, e);
        drawTile(
          GAME_SPRITES.key.tiles[0],
          DEFAULT_TILE_COLORS.key,
          4.5,
          0.75,
          ORIENTATION_UP,
          1,
          uiCtx,
        ),
          uiCtx.fillText(`x${collectedKeysNumber}`, 0.28 * uiCanvas.width, e),
          uiCtx.fillText('R: Reset', 0.8 * uiCanvas.width, 0.7 * e),
          uiCtx.fillText('Undo', 0.8 * uiCanvas.width, 1.3 * e);
      }
      function adjustFontSize(e) {
        let M = e.length;
        for (
          uiCtx.font = '40px Arial';
          uiCtx.measureText(e).width > uiCanvas.width * M * 0.02;

        )
          uiCtx.font = parseInt(uiCtx.font) - 1 + 'px Arial';
      }
      function refreshCanvas() {
        drawLevel(), refreshUI(), drawCharacter();
      }
      function drawLevel() {
        drawLevelBackground('sand', 'rock'),
          drawLevelElements(levelData),
          backgroundCtx.drawImage(
            canvas,
            0,
            0,
            backgroundCanvas.width,
            backgroundCanvas.height,
          );
      }
      function drawLevelBackground(e, M) {
        (backgroundTile = GAME_SPRITES[e].tiles[0]),
          (backgroundColors = DEFAULT_TILE_COLORS[e]);
        const t = GAME_SPRITES[M].tiles[0],
          r = DEFAULT_TILE_COLORS[M];
        for (let e = 0; e < LEVEL_HEIGHT; e++)
          for (let M = 0; M < LEVEL_WIDTH; M++)
            drawTile(backgroundTile, backgroundColors, M, e),
              (0 !== M &&
                M !== LEVEL_WIDTH - 1 &&
                0 !== e &&
                e !== LEVEL_HEIGHT - 1) ||
                drawTile(t, r, M, e);
      }
      function drawLevelElements(e) {
        e.forEach((e) => {
          drawTile(
            GAME_SPRITES[e.tile].tiles[e.animationFrame || 0],
            e.color || DEFAULT_TILE_COLORS[e.tile],
            e.x,
            e.y,
            e.orientation || ORIENTATION_UP,
            e.scale || 1,
          );
        });
      }
      function drawTile(e, M, t, r, a = ORIENTATION_UP, n = 1, l = ctx) {
        l.save();
        const i = (TILE_SIZE * zoomFactor) / 2,
          o = (e) => (e + 0.5) * TILE_SIZE * zoomFactor;
        l.translate(o(t), o(r)),
          l.rotate((a * Math.PI) / 2),
          ctx.scale(n, n),
          l.translate(-i, -i);
        for (let t = 0; t < e.length; t++)
          for (let r = 0; r < e[t].length; r++) {
            const a = e[t][r];
            a > 0 &&
              ((l.fillStyle = M[a - 1]),
              l.fillRect(
                r * zoomFactor,
                t * zoomFactor,
                zoomFactor,
                zoomFactor,
              ));
          }
        l.restore();
      }
      let playerX = 9,
        playerY = 7,
        initialX = playerX,
        initialY = playerY,
        stepsRemaining = 13;
      function drawCharacter() {
        drawTile(
          GAME_SPRITES.characters.tiles[0],
          DEFAULT_TILE_COLORS.character,
          playerX,
          playerY,
        );
      }
      function canMoveTo(e, M, t = 0, r = 0) {
        if (e < 1 || e >= LEVEL_WIDTH - 1 || M < 1 || M >= LEVEL_HEIGHT - 1)
          return !1;
        const a = getTileAt(e, M),
          n = levelData.find((t) => t.x === e && t.y === M);
        if (n && n.isBeingRemoved)
          return console.log('Tile is being removed:', n), !1;
        switch (a) {
          case 'crate':
            moveCrate(e, M, t, r) && stepsRemaining--;
            break;
          case 'key':
            stepsRemaining--,
              removeTile('key'),
              collectedKeysNumber++,
              zzfx(...[, 0, 1320, , 0.1, 0.3, 1, 1.82, , , 880, 0.05]);
            break;
          case 'lock':
            collectedKeysNumber > 0 &&
              (stepsRemaining--,
              animateTileRemoval('lock', e, M, () => {
                collectedKeysNumber--;
              }));
            break;
          case 'flag':
            return resetLevel(), !1;
          case 'block':
            const a = levelData.find(
              (t) => t.x === e && t.y === M && 'block' === t.tile,
            );
            if (a) {
              const n = a.orientation || ORIENTATION_UP;
              (a.color || DEFAULT_TILE_COLORS.block) === COLOR_SETS.greenSet &&
                ((n === ORIENTATION_LEFT && -1 === t) ||
                  (n === ORIENTATION_RIGHT && 1 === t) ||
                  (n === ORIENTATION_UP && -1 === r) ||
                  (n === ORIENTATION_DOWN && 1 === r)) &&
                (removeConnectedBlocks(e, M, t, r), stepsRemaining--);
            }
            break;
          case 'gong-trigger':
            n.triggered ||
              ((n.triggered = !0),
              stepsRemaining--,
              animateTileRemoval('gong'));
        }
        return !![null, 'arrow', 'key', 'key-holder', 'flag'].includes(a);
      }
      function moveCharacter(e, M) {
        const t = playerX + e,
          r = playerY + M;
        canMoveTo(t, r, e, M)
          ? ((playerX = t),
            (playerY = r),
            stepsRemaining--,
            stepsRemaining <= 0 && resetPlayer())
          : console.log('Movement blocked by:', getTileAt(t, r));
      }
      function resetPlayer() {
        (playerX = initialX), (playerY = initialY), (stepsRemaining = 13);
      }
      function handleKeyPress(e) {
        switch (e.key) {
          case 'ArrowUp':
          case 'z':
          case 'w':
            moveCharacter(0, -1);
            break;
          case 'ArrowDown':
          case 's':
            moveCharacter(0, 1);
            break;
          case 'ArrowLeft':
          case 'q':
          case 'a':
            moveCharacter(-1, 0);
            break;
          case 'ArrowRight':
          case 'd':
            moveCharacter(1, 0);
            break;
          case 'r':
            resetLevel();
        }
      }
      window.addEventListener('keydown', handleKeyPress);
      let lastFrameTime = 0;
      function animate(e) {
        updateAnimations(e - lastFrameTime),
          refreshCanvas(),
          (lastFrameTime = e),
          requestAnimationFrame(animate);
      }
      function updateAnimations(e) {
        levelData.forEach((M) => {
          if (GAME_SPRITES[M.tile].tiles.length > 1) {
            M.elapsed = (M.elapsed || 0) + e;
            const t = M.animationInterval || DEFAULT_ANIMATION_INTERVAL;
            M.elapsed >= t &&
              ((M.animationFrame =
                (M.animationFrame + 1) % GAME_SPRITES[M.tile].tiles.length),
              (M.elapsed = 0));
          }
          if (M.isBeingRemoved) {
            M.elapsed = (M.elapsed || 0) + e;
            const t = M.removalDuration || DEFAULT_REMOVAL_DURATION;
            (M.scale = Math.max(1 - M.elapsed / t, 0)),
              M.scale <= 0 &&
                (removeTile(M.tile, M.x, M.y),
                M.removeCallback && M.removeCallback());
          }
        });
      }
      let playSoundButton = document.getElementById('testSound');
      function setZoomFactor() {
        (zoomFactor = Math.min(
          Math.floor(window.innerWidth / (LEVEL_WIDTH * TILE_SIZE)),
          Math.floor(window.innerHeight / (LEVEL_HEIGHT * TILE_SIZE)),
        )),
          (canvas.width = LEVEL_WIDTH * TILE_SIZE * zoomFactor),
          (canvas.height = LEVEL_HEIGHT * TILE_SIZE * zoomFactor),
          (uiCanvas.width = canvas.width),
          (uiCanvas.height = TILE_SIZE * zoomFactor * 2),
          window.innerWidth / window.innerHeight > LEVEL_WIDTH / LEVEL_HEIGHT
            ? ((backgroundCanvas.width = window.innerWidth),
              (backgroundCanvas.height =
                window.innerWidth * (LEVEL_HEIGHT / LEVEL_WIDTH)))
            : ((backgroundCanvas.height = window.innerHeight),
              (backgroundCanvas.width =
                window.innerHeight * (LEVEL_WIDTH / LEVEL_HEIGHT)));
      }
      function initGame() {
        (ctx.imageSmoothingEnabled = !1),
          levelData.forEach((e) => {
            e.animationFrame = 0;
          }),
          window.addEventListener('resize', setZoomFactor),
          setZoomFactor(),
          requestAnimationFrame(animate);
      }
      playSoundButton.addEventListener('click', function () {
        zzfx(...[, 0, 220, , 0.1, 0.3, 1, 1.82, , , 880, 0.05]);
      }),
        initGame();
    </script>
  </body>
</html>
